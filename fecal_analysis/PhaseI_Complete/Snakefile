"""Performing grouping and taxonomic taxonomic_classification

*Grouping reads to OTU's
Use three methods to group reads into OTU's, using an assigned level of similarity
- de novo
- closed-reference
- open-reference

*Taxonomic classification
Use three methods to classify the taxonomic classes
- BLAST+
- VSEARCH
- de novo
"""
import os
import re
import subprocess
import sys

# reference the config file
conf = os.environ.get("conf")
configfile: conf

out_dir = config['out_dir'].rstrip('/') + '/'
exec_dir = config['exec_dir'].rstrip('/') + '/'

table_dir = config['table_dir']
repseq_dir = config['repseq_dir']
rawref_dir = config['raw_ref_dir'].rstrip('/') + '/'
filt_file = config['filt_file_dir']
clust_dir = config['clust_dir']
tax_dir = config['tax_dir']

de_novo_id = config['de_novo_id']
closed_id = config['closed_id']
open_id = config['open_id']

#Inputs

#ref_in = rawref_dir + 'gg_13_8_otus/rep_set/99_otus.fasta'
#ref_db = clust_dir + 'gg_ref.qza'

REF_DB = ['gg_13_8_otus/rep_set/99_otus.fasta', 'SILVA_132_QIIME_release/rep_set/rep_set_16S_only/99/silva_132_99_16S.fna']

refDict = {}
for i in REF_DB:
    refFile = os.path.basename(rawref_dir + i)
    refNoExt = i.split('_')[0]
    refDict[refNoExt] = (rawref_dir + i)

def get_ref_full_path(wildcards):
    """
    """
    (refFullPath) = refDict[wildcards.ref]
    return refFullPath

rule all:
    input:
        expand(clust_dir + 'output/table_dn_{ref}_{de_novo_id}.qza', de_novo_id=de_novo_id, ref=refDict.keys()),
        expand(clust_dir + 'output/rep-seqs_dn_{ref}_{de_novo_id}.qza', de_novo_id=de_novo_id, ref=refDict.keys()),
        expand(clust_dir + 'output/table_cl_{ref}_{closed_id}.qza', closed_id=closed_id, ref=refDict.keys()),
        expand(clust_dir + 'output/rep-seqs_cl_{ref}_{closed_id}.qza', closed_id=closed_id, ref=refDict.keys()),
        expand(clust_dir + 'output/unmatched_cl_{ref}_{closed_id}.qza', closed_id=closed_id, ref=refDict.keys()),
        expand(clust_dir + 'output/table_op_{ref}_{open_id}.qza', open_id=closed_id, ref=refDict.keys()),
        expand(clust_dir + 'output/rep-seqs_op_{ref}_{open_id}.qza', open_id=closed_id, ref=refDict.keys()),
        expand(clust_dir + 'output/new_op_{ref}_{open_id}.qza', open_id=closed_id, ref=refDict.keys())

rule feature_filt:
    """Filter features that have less than 32 reads
    VSEARCH will automatically remove features with <32 reads, however, QIIME2 does not do this. When the results are returned to Q2 without these reads, a KEYERROR is received.

    In order to determine which features, use the TABLE QZV and determine which features meet this requirement. Then create a TSV file with these features to pass through as a parameter of exclusion.

    NOTE: Removing features by count (<2 for example) would eliminate too many features that do not meet this criterion and may not even eliminate all of the targeted features.
    """
    input:
        tab_in = table_dir,
        f_list = filt_file
    output:
        tab_f = clust_dir + "output/filt_tab.qza"
    run:
        shell('qiime feature-table filter-features \
        --i-table {input.tab_in} \
        --m-metadata-file {input.f_list} \
        --p-exclude-ids \
        --o-filtered-table {output.tab_f}')

rule seq_filt:
    """
    Rep-seqs must match features with the feature-table. Since features were filtered with rule above, this rule will remove those features from the rep-seq list.
    """
    input:
        tab_f = clust_dir + "output/filt_tab.qza",
        rep_in = repseq_dir
    output:
        rep_f = clust_dir + "output/filt_seq.qza"
    run:
        shell('qiime feature-table filter-seqs \
        --i-data {input.rep_in} \
        --i-table {input.tab_f} \
        --o-filtered-data {output.rep_f}')

rule create_ref:
    """ Create the reference database to be used for taxonomic_classification
    used unaligned reads for this
    """
    input:
        ref = get_ref_full_path
    output:
        clust_dir + 'output/refdb_{ref}.qza'
    run:
        shell('qiime tools import \
        --type ''FeatureData[Sequence]'' \
        --input-path {input.ref} \
        --output-path {output}')

rule vsearch_de_novo:
    input:
        tab_f = clust_dir + "output/filt_tab.qza",
        rep_f = clust_dir + "output/filt_seq.qza"
    params:
        dn_id = de_novo_id
    output:
        out_tab = clust_dir + 'output/table_dn_{ref}_{de_novo_id}.qza',
        out_rep = clust_dir + 'output/rep-seqs_dn_{ref}_{de_novo_id}.qza'
    run:
        shell('qiime vsearch cluster-features-de-novo \
        --i-table {input.tab_f} \
        --i-sequences {input.rep_f} \
        --p-perc-identity {params.dn_id} \
        --o-clustered-table {output.out_tab} \
        --o-clustered-sequences {output.out_rep}')

rule vsearch_closed_ref:
    input:
        tab_f = clust_dir + "output/filt_tab.qza",
        rep_f = clust_dir + "output/filt_seq.qza",
        ref_qza = clust_dir + "output/refdb_{ref}.qza"
    params:
        cl_id = closed_id
    output:
        out_tab = clust_dir + 'output/table_cl_{ref}_{closed_id}.qza',
        out_rep = clust_dir + 'output/rep-seqs_cl_{ref}_{closed_id}.qza',
        out_unmat = clust_dir + 'output/unmatched_cl_{ref}_{closed_id}.qza'
    run:
        shell('qiime vsearch cluster-features-closed-reference \
        --i-table {input.tab_f} \
        --i-sequences {input.rep_f} \
        --i-reference-sequences {input.ref_qza} \
        --p-perc-identity {params.cl_id} \
        --o-clustered-table {output.out_tab} \
        --o-clustered-sequences {output.out_rep} \
        --o-unmatched-sequences {output.out_unmat}')

rule vsearch_open_ref:
    input:
        tab_f = clust_dir + "output/filt_tab.qza",
        rep_f = clust_dir + "output/filt_seq.qza",
        ref_qza = clust_dir + "output/refdb_{ref}.qza"
    params:
        op_id = open_id
    output:
        out_tab = clust_dir + 'output/table_op_{ref}_{open_id}.qza',
        out_rep = clust_dir + 'output/rep-seqs_op_{ref}_{open_id}.qza',
        out_new = clust_dir + 'output/new_op_{ref}_{open_id}.qza'
    run:
        shell('qiime vsearch cluster-features-open-reference \
        --i-table {input.tab_f} \
        --i-sequences {input.rep_f} \
        --i-reference-sequences {input.ref_qza} \
        --p-perc-identity {params.op_id} \
        --o-clustered-table {output.out_tab} \
        --o-clustered-sequences {output.out_rep} \
        --o-new-reference-sequences {output.out_new}')
